[{"content":"In my previous post, I detailed moving your Traefik configuration to a slightly more permanent format (YAML\u0026hellip; I know, just go with it). You might have then been tempted to go to SSL Labs and do an SSL Test. What you would have discovered, in that tragic scenario, is a mere B grade!\n\u0026ldquo;Why, oh why?\u0026rdquo; I hear you cry, \u0026ldquo;I did everything right!\u0026rdquo; Well, technically you did, so don\u0026rsquo;t feel too bad. It\u0026rsquo;s not a fault of yours that you\u0026rsquo;re letting people with filthy TLS 1.0 and 1.1 view your site. It is, however, the view of certain industry bodies that these technologies are deprecated and therefore have multiple nasty security vulnerabilities.\nCaveats  You\u0026rsquo;re running Traefik in a container, bonus points if you\u0026rsquo;re using Docker Compose You\u0026rsquo;ve backed up your current running config and volume contents You understand basic Docker concepts like bringing containers up and down, and what that will do to your currently running infrastructure  A Quick Recap Now, if you\u0026rsquo;d gone through that previous post I mentioned above, you would have read about the difference between Static and Dynamic configuration in Traefik. A quick reminder:\n Static runs at startup Dynamic runs each time a new request comes in to Traefik  So with Static configuration, we can define the entrypoints upon which Traefik accepts traffic (port 80, 443, etc) but according to Traefik\u0026rsquo;s split of these rules, defining which TLS version is accepted is done Dynamically, i.e. checked every time a new connection comes in to the router. \u0026ldquo;But\u0026hellip; but\u0026hellip;\u0026rdquo; I hear you stammer, \u0026ldquo;I\u0026rsquo;ve only passed through a static configuration file! How do?\u0026rdquo;\nIt really is just as easy as the static configuration file, with one small addition.\nLoading The File To enable us to test this method as we go, we need to create an empty dynamic.yml file in the same directory as the rest of our configuration. Once this is done, we need to add it to our traefik.yml file (or whatever you\u0026rsquo;ve called your static config file) as a \u0026lsquo;Provider.\u0026rsquo; You\u0026rsquo;ll probably also have something like Docker in here too, see the bottom of the post for my full file in context.\nproviders:  file:  filename: /etc/traefik/dynamic.yml The final step is to add this to our docker-compose.yml file so that the container has access to this file. Again, see the bottom of the post for my full file.\nvolumes:  - \u0026#34;./dynamic.yml:/etc/traefik/dynamic.yml\u0026#34; Now, we\u0026rsquo;re ready to add some config to dynamic.yml file!\nThe Dynamic File It\u0026rsquo;s worth mentioning here that I haven\u0026rsquo;t yet seen a successful way to do this via the cmdline and trust me, I\u0026rsquo;ve looked\u0026hellip; This was the impetus for me converting my static config to a YAML file in the first place, so just trust me on that one!\ntls:  options:  default:  minVersion: VersionTLS13 Now, at first glance, this looks like this will solve all of your problems. But if you re-test at this point, you\u0026rsquo;ll notice that the \u0026lsquo;TLS\u0026rsquo; section of the report shows a yellow \u0026lsquo;No\u0026rsquo; by TLS 1.2. This is because TLS 1.2 isn\u0026rsquo;t deprecated yet, it\u0026rsquo;s still perfectly usable and certain individuals who might not have upgraded their browsers in quite some time (or Java 8\u0026hellip;) might not have full TLS 1.3 support.\nSurely that\u0026rsquo;s easy to fix, right? Just amend the \u0026lsquo;13\u0026rsquo; to a \u0026lsquo;12\u0026rsquo; so that your minimum version of TLS is 1.2 and clients can negotiate higher if they like.\ntls:  options:  default:  minVersion: VersionTLS12 Now with this, you\u0026rsquo;ll still get an A grade, but the \u0026lsquo;Ciper Suites\u0026rsquo; section of the report will shed some more light here:\nNow, you don\u0026rsquo;t want to be seen by all of your webmaster friends to be supporting WEAK cipher suites, do you? That would just be embarrassing, every time you turn around and see 2 people whispering and pointing in your direction, you\u0026rsquo;d know exactly what they were talking about! Let\u0026rsquo;s solve that before it becomes a problem. Traefik has a \u0026lsquo;cipherSuites\u0026rsquo; key that we can add to the default configuration which means that all of our sites will automatically only accept these and best of all, we only have to define it once! I\u0026rsquo;ve defined a few accepted ones here, but please DYOR (Do Your Own Research) to make sure that you\u0026rsquo;re happy to support these, or possibly to add more. Our final file, therefore, becomes the below:\ntls:  options:  default:  minVersion: VersionTLS12  cipherSuites:  - TLS_AES_128_GCM_SHA256  - TLS_CHACHA20_POLY1305_SHA256  - TLS_AES_256_GCM_SHA384  - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256  - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256  - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 And you\u0026rsquo;ll also notice the report now shows:\nCongrats, you\u0026rsquo;ve made the grade! :confetti_ball:\nIn a future post, we\u0026rsquo;ll go over upgrading this grade to an A+!\nFull dynamic.yml File tls:  options:  default:  minVersion: VersionTLS12  cipherSuites:  - TLS_AES_128_GCM_SHA256  - TLS_CHACHA20_POLY1305_SHA256  - TLS_AES_256_GCM_SHA384  - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256  - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256  - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 Full traefik.yml (Static) File entryPoints:  http:  address: \u0026#34;:80\u0026#34;   https:  address: \u0026#34;:443\u0026#34;  providers:  docker: {}  file:  filename: /etc/traefik/dynamic.yml  certificatesResolvers:  le:  acme:  email: name@domain.tld  storage: /letsencrypt/acme.json  tlsChallenge: {} Full docker-compose.yml File version: \u0026#34;3.3\u0026#34;  services:  traefik:  container_name: traefik  image: traefik:v2.4.8  labels:  - \u0026#34;traefik.enable=true\u0026#34;  ### Middleware Redirect  - \u0026#34;traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\u0026#34;  ### Global HTTP -\u0026gt; HTTPS Redirect  - \u0026#34;traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\u0026#34;  - \u0026#34;traefik.http.routers.redirs.entrypoints=http\u0026#34;  - \u0026#34;traefik.http.routers.redirs.middlewares=https-redirect\u0026#34;  - \u0026#34;traefik.http.routers.redirs.priority=1\u0026#34;  ports:  - \u0026#34;80:80\u0026#34;  - \u0026#34;443:443\u0026#34;  volumes:  - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34;  - \u0026#34;certs:/letsencrypt\u0026#34;  - \u0026#34;./traefik.yml:/etc/traefik/traefik.yml\u0026#34;  - \u0026#34;./dynamic.yml:/etc/traefik/dynamic.yml\u0026#34;  restart: unless-stopped  networks:  - proxy ","permalink":"https://dangerous.tech/posts/20210524/achievinganagradewithtraefik/","summary":"In my previous post, I detailed moving your Traefik configuration to a slightly more permanent format (YAML\u0026hellip; I know, just go with it). You might have then been tempted to go to SSL Labs and do an SSL Test. What you would have discovered, in that tragic scenario, is a mere B grade!\n\u0026ldquo;Why, oh why?\u0026rdquo; I hear you cry, \u0026ldquo;I did everything right!\u0026rdquo; Well, technically you did, so don\u0026rsquo;t feel too bad.","title":"Achieving an A Grade with Traefik"},{"content":"In this post, I shared my Traefik configuration. Back then, I\u0026rsquo;d just learned about Traefik and followed a few posts to set things up and get them working with all of my containers. Since then, I\u0026rsquo;ve used Traefik for every new container I\u0026rsquo;ve set up, I\u0026rsquo;ve run servers like Minecraft and 7 Days to Die through it, as well as numerous different DevOps-adjacent containers. So whilst I\u0026rsquo;m no means an expert, I\u0026rsquo;m definitely a little more adept at some of its configuration nuances (I\u0026rsquo;ll be publishing something next week about how to globally disable TLS 1.0 and 1.1 so keep an eye out for that).\nCaveats As per normal, ensure the below are met before starting this:\n You\u0026rsquo;ve backed up your current config, certs volume, docker-compose.yml file and/or anything related to the running version of Traefik You\u0026rsquo;re doing this with Traefik in a Docker container  The same principal applies to a natively running version of Traefik I suppose, just ignore the bit about passing the file through to the container   You understand basic Docker concepts such as bringing a container up and down, and managing your configuration through a docker-compose.yml file  Static or Dynamic? The best descriptor of the differences is probably the image above. All you really need to be concerned about is the following:\n Static runs at startup Dynamic runs each time a new request comes in to Traefik  Because of this distinction, there are certain elements that fit naturally into each of these categories. In the current config (located at the bottom of the post), Static options are provided via the \u0026lsquo;command\u0026rsquo; key. There are certain Dynamic options that can be specified in the \u0026rsquo;labels\u0026rsquo; key (the normal router creation, certresolver binding, etc) but we won\u0026rsquo;t go over those in detail just yet.\nConverting YAML Into\u0026hellip; YAML? Technically, to convert from the cmdline style flags to a permanent YAML file we\u0026rsquo;re going from docker-compose.yml to traefik.yml, but you\u0026rsquo;ll see that the format will wind up looking a little different. If you\u0026rsquo;ve worked with JSON at all, the way to split these up should look rather familiar. The basic gist is that everywhere you see a period, you insert a new line.\nAs an example, the command argument\n- --entrypoints.http.address=:80\nwill translate into\nentryPoints:  http:  address: 80 Create a file called traefik.yml in the same directory as your docker-compose.yml file (or don\u0026rsquo;t, I\u0026rsquo;m not your dad\u0026hellip; Just don\u0026rsquo;t forget to amend the final volume mapping below) and convert these lines into sweet, sweet YAML. Once you\u0026rsquo;ve completed the whole \u0026lsquo;command\u0026rsquo; key, you should have a file like the below (certain config will accept either true or {} as valid to turn them on, always worth double checking the docs for which is preferred):\nentryPoints:  http:  address: \u0026#34;:80\u0026#34;   https:  address: \u0026#34;:443\u0026#34;  providers:  docker: {}  certificatesResolvers:  le:  acme:  email: name@email.tld  storage: /letsencrypt/acme.json  tlsChallenge: {} That Rug Really Tied The Room Together Now you have a static file on the host system, viola. Remove the \u0026lsquo;command\u0026rsquo; key, rebuild the container and you\u0026rsquo;re ready to go!\nWhat\u0026rsquo;s that? Your container is giving you an error that it can\u0026rsquo;t find the file you just created? Ahhh\u0026hellip; We probably should have actually utilised that new file somehow, huh?\nWell then, ignoring that small blunder, just add a line to your volume mappings to make the file visible inside the container (/etc/traefik/traefik is the default location that Traefik will look for config). This is where you change the left hand side of the mapping if you located your traefik.yml file elsewhere\u0026hellip;\n- \u0026quot;./traefik.yml:/etc/traefik/traefik.yml\u0026quot;\nand you\u0026rsquo;re off to the races! Just bring the container down (you are storing your certs in a separate volume, riiiiiiight?) and back up again and Traefik will now reload, giving you this nifty little confirmation:\nNow, if you ever want to add configuration to the Static options for Traefik, you just have to add them to this file and restart the container. The documentation is always a little bit more helpful when using YAML, as all things aren\u0026rsquo;t necessarily formatted for cmdline on the website.\nPrevious Traefik Config version: \u0026#34;3.3\u0026#34;  services:  traefik:  container_name: traefik  image: traefik:v2.4.8  command:  # - --log.level=DEBUG  # Entrypoints  - --entrypoints.http.address=:80  - --entrypoints.https.address=:443  # Provider Info  - --providers.docker  # Certificate Resolver Info  - --certificatesresolvers.le.acme.email=name@email.tld  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json  - --certificatesresolvers.le.acme.tlschallenge=true  labels:  - \u0026#34;traefik.enable=true\u0026#34;  ### Middleware Redirect  - \u0026#34;traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\u0026#34;  ### Global HTTP -\u0026gt; HTTPS Redirect  - \u0026#34;traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\u0026#34;  - \u0026#34;traefik.http.routers.redirs.entrypoints=http\u0026#34;  - \u0026#34;traefik.http.routers.redirs.middlewares=https-redirect\u0026#34;  - \u0026#34;traefik.http.routers.redirs.priority=1\u0026#34;  ports:  - \u0026#34;80:80\u0026#34;  - \u0026#34;443:443\u0026#34;  volumes:  - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34;  - \u0026#34;certs:/letsencrypt\u0026#34;  restart: unless-stopped  networks:  - proxy  volumes:  certs:  networks:  proxy:  driver: bridge New Traefik Config version: \u0026#34;3.3\u0026#34;  services:  traefik:  container_name: traefik  image: traefik:v2.4.8  labels:  - \u0026#34;traefik.enable=true\u0026#34;  ### Middleware Redirect  - \u0026#34;traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\u0026#34;  ### Global HTTP -\u0026gt; HTTPS Redirect  - \u0026#34;traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\u0026#34;  - \u0026#34;traefik.http.routers.redirs.entrypoints=http\u0026#34;  - \u0026#34;traefik.http.routers.redirs.middlewares=https-redirect\u0026#34;  - \u0026#34;traefik.http.routers.redirs.priority=1\u0026#34;  ports:  - \u0026#34;80:80\u0026#34;  - \u0026#34;443:443\u0026#34;  volumes:  - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34;  - \u0026#34;certs:/letsencrypt\u0026#34;  - \u0026#34;./traefik.yml:/etc/traefik/traefik.yml\u0026#34;  restart: unless-stopped  networks:  - proxy  volumes:  certs:  networks:  proxy:  driver: bridge ","permalink":"https://dangerous.tech/posts/20210517/learningtoloveyaml_converitngyourtraefiksetupfromcmdlinetoyaml/","summary":"In this post, I shared my Traefik configuration. Back then, I\u0026rsquo;d just learned about Traefik and followed a few posts to set things up and get them working with all of my containers. Since then, I\u0026rsquo;ve used Traefik for every new container I\u0026rsquo;ve set up, I\u0026rsquo;ve run servers like Minecraft and 7 Days to Die through it, as well as numerous different DevOps-adjacent containers. So whilst I\u0026rsquo;m no means an expert, I\u0026rsquo;m definitely a little more adept at some of its configuration nuances (I\u0026rsquo;ll be publishing something next week about how to globally disable TLS 1.","title":"Learning to Love YAML - Converting Your Traefik Setup From Cmdline into YAML"},{"content":"The previous post on this topic is still relevant, however, since my selection of a new reverse proxy, I felt it necessary to publish an update.\nAssumptions  You know what HTTPS and SSL certificates are/do and how the CA ecosystem works You have a domain that you plan to use for the Jenkins instance and this domain either doesn\u0026rsquo;t have a CAA record or has one that allows LetsEncrypt You understand the general working of containers and have docker installed on your system. Docker/Docker Compose knowledge is a plus but not required, you can basically just copy/paste code to get this working. I\u0026rsquo;ll also go over some common pitfalls at the end You either have your own reverse proxy setup and can handle this or you\u0026rsquo;re using my Traefik config You know what Jenkins is and why you should be using it. If you don\u0026rsquo;t, use the Google machine  OK, let\u0026rsquo;s get this show on the road.\nPrerequisites  A linux environment - because there\u0026rsquo;s a special circle of hell reserved for you if you\u0026rsquo;re doing this on Windows (just kidding\u0026hellip;) Docker Docker-compose A domain and the ability to add A records Tea/Coffee because caffeine  1 - Checking Your Install At the time of writing, I\u0026rsquo;ve got the docker and docker-compose versions below. If these become wildly out of date I\u0026rsquo;ll try to update in the future. Or shoot me an angry email on the About Me page and I\u0026rsquo;ll get right to it! If you can\u0026rsquo;t be bothered to read the walkthrough and just want the files, they\u0026rsquo;re pasted at the bottom of the post. I gotchu.\nAs long as your docker --version and docker-compose --version outputs are these versions or later, this should work fine. If they\u0026rsquo;re not, check if you\u0026rsquo;ve got installed via snap or pip or something as they sometimes don\u0026rsquo;t update versions frequently. Official docker install process is here if you need it\nYou can also run docker run hello-world to make sure containers are running properly.\n2 - Adding Your A Record Before we get all the nifty LetsEncrypt bits done, you need to have a domain that resolved to the IP of your server/raspberry pi/nan\u0026rsquo;s old laptop. Hopefully you\u0026rsquo;ve got a VPS with a public IPv4 adress you can use, if not get comfortable with port forwarding. You\u0026rsquo;ll need to forward TCP 80 and 443 inbound because LetsEncrypt still uses 80 for one of the validation challenges.\nCreate an A record however the Good Lord GoDaddy lets you (or use a respectable registrar/DNS provider ;)). This can be on the root domain or any subdomain, we\u0026rsquo;re not getting fancy and doing wildcard certificates here, I\u0026rsquo;ll probably cover that in another post.\n3 - Compose Like Vivaldi OK so here\u0026rsquo;s where we get into the docker-compose magic. There\u0026rsquo;s another post explaining the proxy in detail so if you\u0026rsquo;d like to read up on that, check it out here. You can grab the correct proxy config from that of this page and just docker-compose up -d that bad boy. Therefore, we\u0026rsquo;ll jump straight to the Jenkins YAML file.\nversion: \u0026#39;3\u0026#39;  services:  jenkins:  container_name: jenkins  image: jenkins/jenkins:lts  restart: unless-stopped We start with the basics, version and services because we\u0026rsquo;re keeping to the standard like good, rule followers™. Next, we name the service and container something sensible and pull the jenkins/jenkins:lts image. You can use the :latest tag instead of :lts if you want the bleeding edge releases but I\u0026rsquo;d like my build server to be nice stable personally\u0026hellip; restart: unless-stopped has the advantage of restarting the container automatically if you reboot the OS of the machine that it\u0026rsquo;s running on but doesn\u0026rsquo;t get too aggressive if there\u0026rsquo;s a critical error that you need to stop the container for.\nlabels:  - \u0026#34;traefik.enable=true\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.entrypoints=https\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.rule=Host(`sub.domain.tld`)\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.tls.certresolver=le\u0026#34;  - \u0026#34;traefik.http.services.jenkins.loadbalancer.server.port=8080\u0026#34; Labels are how we tell Traefik how to route traffic for this container. Because Jenkins for some reason won\u0026rsquo;t let you change the port that it\u0026rsquo;s running on, you always have to proxy across to 8080. The loadbalancer label means that the proxy will take 443 traffic (designated by the entrypoint=https (more on this in the post about my Traefik setup)) on whatever the Host URL is and forward it to 8080 on the container so Jenkins is none the wiser. Neat!\nvolumes:  - jenkins_home:/var/jenkins_home  networks:  - traefik_proxy  volumes:  jenkins_home:  networks:  traefik_proxy:  external: true Next there\u0026rsquo;s the volume goodness. Fairly standard, nothing special here. If you want to get creative and map a specific local place in the filesystem you can change the named mapping to a bind mount, as detailed in the docker docs. We have to declare this named volume at the bottom by itself because we\u0026rsquo;re being rule followers™, remember?\n4 - Run Forrest, Run Now, it\u0026rsquo;s time to put the butler to work. Worth mentioning that you should have your proxy up and running by this point, docker-compose up -d if you dont. docker-compose up -d \u0026amp;\u0026amp; docker-compose logs -f will do the trick. It\u0026rsquo;ll grab the relevant images, start like magic on the first attempt and then show you the logs of a fledgling jetty server doing it\u0026rsquo;s thing. You\u0026rsquo;ll also, crucially, see the below little chunk of text.\nGrab that password and browse to the domain that you\u0026rsquo;ve pointed at this server. If you get some weird browser error, give it 30 seconds, dump the cache and refresh. The proxy container probably just took a second to get all the certs in order. If all went well, you should be greeted with the below screen.\nYou guessed it, stick that admin password in and hit Continue!\nThis one depends on if you know what you\u0026rsquo;re doing, I normally just hit the \u0026lsquo;Install suggested plugins\u0026rsquo; options. You can always pick other specific ones later on.\nThen some nifty plugin installing will commence. This will take a minute so grab a cup of tea. Containerising without tea is uncivilised, you should know that already!\nNow you\u0026rsquo;ll create an admin user. Bob the builder is really the only user that makes sense in the context of creating a build server but if you have some other cool name like Jeffrey or Federcio then go ahead and enter that instead. I can\u0026rsquo;t stop you from making the wrong decisions, I can only try and advise you against them\u0026hellip; Also we know Bob The Builder is the type of dude to still have an AOL email account, don\u0026rsquo;t @ me.\nThis next page should have picked up your install URL because you\u0026rsquo;ve browsed to it but if not, pop the FQDN in here to avoid any wrongly genearted links in the future.\nCongratuwelldone! The butler is at your service.\nCan you smell that? That new server smell? Smells like hope with notes of long nights figuring out why it builds locally but Jenkins hates you. That\u0026rsquo;s all yet to come, friends. I\u0026rsquo;ll be writing more Jenkins posts as I set up build pipelines in various differnet environments so keep your eyes peeled for those scintillating pieces of writing.\n","permalink":"https://dangerous.tech/posts/20200615/updatejenkinswithhttpsinadockercontainer/","summary":"The previous post on this topic is still relevant, however, since my selection of a new reverse proxy, I felt it necessary to publish an update.\nAssumptions  You know what HTTPS and SSL certificates are/do and how the CA ecosystem works You have a domain that you plan to use for the Jenkins instance and this domain either doesn\u0026rsquo;t have a CAA record or has one that allows LetsEncrypt You understand the general working of containers and have docker installed on your system.","title":"UPDATE: Jenkins with HTTPS in a Docker Container"},{"content":"Twitter? Garbage. Facebook? Garbage. Do you enjoy having your data harvested and sold? No? Good. Back in the day, there was this thing called Internet Relay Chat. What if I told you\u0026hellip; It still exists! Internet socializing without all the Silicon Valley data theft! But due to how the ecosystem works, any time you\u0026rsquo;re not actively connected to the server, you don\u0026rsquo;t receive any messages. This means that you don\u0026rsquo;t get to see conversations that happen while you\u0026rsquo;re offline, even if somebody mentions you!\nEnter the IRC Bouncer. This nifty little piece of software sits behind the scenes and stays connected to the IRC server(s) whilst you\u0026rsquo;re sleeping, working or doing other things that happen IRL. Then when you return to where you\u0026rsquo;re supposed to be (i.e. in front of a computer) you reconnect and the bouncer greets you with a flood of glorious, nerdy conversations.\nAssumptions  You know why HTTPS is necessary and will use it You understand the general working of containers and have docker installed on your system. (Docker/Docker Compose knowledge is a plus but not required, you can basically just copy/paste code to get this working.) Your domain/subdomain has a CAA record that supports LetsEncrypt  You Will Need  A linux environment - or WSL I guess, if you hate yourself\u0026hellip; which is actually pretty good now Docker Docker-compose An A record pointed at your environment\u0026rsquo;s public IP (for LetsEncrypt to validate the SSL cert) Your caffeinated beverage of choice  1 - Checking Your Install See Step 1 from this post for further version instructions. The short of it is that I\u0026rsquo;m using docker 19.03.1 and docker-compose 1.21.0.\n2 - Generate a Basic ZNC Config As per usual, we\u0026rsquo;re using a reverse proxy for this component so if you\u0026rsquo;re not using that, you can either ignore those particular parts or you can set that sucker up using the instructions in this post. The config is also on GitHub.\nBefore we compose all the things, we first have to generate the base ZNC config. If you\u0026rsquo;re migrating from an old install, just migrate the whole znc folder to /var/lib/docker/volumes/YOURVOLUMENAME/_data/.\n2.1 - Generate Config Run docker run -it -v znc_znc_data:/znc-data znc --makeconf then follow the process through like the below (you should customize your username, nicks, ident and bind host though).\n[ .. ] Checking for list of available modules... [ ** ] [ ** ] -- Global settings -- [ ** ] [ ?? ] Listen on port (1025 to 65534): 6697 [ ?? ] Listen using SSL (yes/no) [no]: yes [ .. ] Verifying the listener... [ ** ] Unable to locate pem file: [/znc-data/znc.pem], creating it [ .. ] Writing Pem file [/znc-data/znc.pem]... [ ** ] Enabled global modules [webadmin] [ ** ] [ ** ] -- Admin user settings -- [ ** ] [ ?? ] Username (alphanumeric): yournamehere [ ?? ] Enter password: nicensecure [ ?? ] Confirm password: nicensecure [ ?? ] Nick [yournamehere]: yournickhere [ ?? ] Alternate nick [yournamehere_]: youraltnickhere [ ?? ] Ident [yournamehere]: youridenthere [ ?? ] Real name (optional): yourmeatspacenamehere [ ?? ] Bind host (optional): leavethisblankit\\\u0026#39;spointless [ ** ] Enabled user modules [chansaver, controlpanel] [ ** ] [ ?? ] Set up a network? (yes/no) [yes]: no [ ** ] [ .. ] Writing config [/znc-data/configs/znc.conf]... [ ** ] [ ** ] To connect to this ZNC you need to connect to it as your IRC server [ ** ] using the port that you supplied. You have to supply your login info [ ** ] as the IRC server password like this: user/network:pass. [ ** ] [ ** ] Try something like this in your IRC client... [ ** ] /server \u0026lt;znc_server_ip\u0026gt; +6697 yournamehere:\u0026lt;pass\u0026gt; [ ** ] [ ** ] To manage settings, users and networks, point your web browser to [ ** ] https://\u0026lt;znc_server_ip\u0026gt;:6697/ [ ** ] [ ?? ] Launch ZNC now? (yes/no) [yes]: no 2.2 - Add a Listener to ZNC You can do this in 1 of 2 ways:\n  Log into the webadmin GUI, go to the Global Settings section and add the listener there.\n  Edit the config directly with vim /var/lib/docker/volumes/YOURVOLUMENAME/_data/configs/znc.conf\n  \u0026lt;Listener listener0\u0026gt;  AllowIRC = true  AllowWeb = false  IPv4 = true  IPv6 = false  Port = 6697  SSL = true  URIPrefix = / \u0026lt;/Listener\u0026gt;  \u0026lt;Listener listener1\u0026gt;  AllowIRC = false  AllowWeb = true  IPv4 = true  IPv6 = false  Port = 8080  SSL = false  URIPrefix = /znc/ \u0026lt;/Listener\u0026gt; The listeners basically operate thusly: one is for the actual IRC network connections and one is for the webadmin frontend. We only need to reverse proxy the web GUI port, and that\u0026rsquo;s the only easy one to do with Traefik. The ZNC Wiki has some opinions on using NGINX for that purpose but I haven\u0026rsquo;t tried it so your mileage may vary. I don\u0026rsquo;t really see the extra benefits of reverse proxying the IRC connection but maybe I will have my eyes opened in the future, at which point I\u0026rsquo;ll update this post. Also, you can use whatever port you like for the web listener, we\u0026rsquo;re going to forward that from 443 -\u0026gt; containerPort by Traefik so as long as you\u0026rsquo;re consistent then you\u0026rsquo;re alright.\n2.3 Make a Compose File and Add Traefik Container Labels Because we\u0026rsquo;re not animals who just run containers with a command and then leave, we need to pop this into a docker-compose.yml file. As per the general Traefik config, we have to add the labels to our ZNC container so that our traffic gets routed properly.\nversion: \u0026#39;3\u0026#39;  services:  znc:  container_name: znc  image: znc:1.8.0  restart: unless-stopped  ports:  - 6697:6697  labels:  - \u0026#34;traefik.enable=true\u0026#34;  # Web Frontend Rules  - \u0026#34;traefik.http.routers.znc.entrypoints=https\u0026#34;  - \u0026#34;traefik.http.routers.znc.rule=Host(`sub.domain.tld`)\u0026#34;  - \u0026#34;traefik.http.routers.znc.tls.certresolver=le\u0026#34;  - \u0026#34;traefik.http.services.znc.loadbalancer.server.port=8080\u0026#34;  volumes:  - znc_data:/znc-data  networks:  - traefik_proxy  volumes:  znc_data:  networks:  traefik_proxy:  external: true This one\u0026rsquo;s pretty simple, all in all. Because we\u0026rsquo;re not reverse proxying the IRC connection, this is just a case of adding your domain to the Host rule so that the container gets an SSL cert and using the correct port in the loadbalancer section (make it the same as the one from the listener above and you\u0026rsquo;ll be fine). Oh and make sure to reference your Traefik proxy network as external (you definitely created one of those, right?).\n3 - Extract The Certs From Traefik The above will get you up and running with a cert, but at the moment the ZNC config is simply pointing to the znc.pem file that it created way back in step 2.1. If you look in your znc.conf file, you\u0026rsquo;ll see these sections right at the top (the cert names may be different, I\u0026rsquo;m not creating this from scratch just to get that detail right\u0026hellip; the options are what\u0026rsquo;s important):\nSSLCertFile = /znc-data/certificate.pem SSLDHParamFile = /znc-data/dhparam.pem SSLKeyFile = /znc-data/privatekey.pem You\u0026rsquo;ll notice, if you go and have a look at your Traefik data volume, that all you have in there is an acme.json file. This file is where Traefik keeps all your certs, but ZNC won\u0026rsquo;t read such a file as it\u0026rsquo;s looking for .pem files.\nEnter traefik-certs-dumper (referred to henceforth as TCD for brevity). This is a really neat container that you can just add to your Traefik docker-compose.yml file in order to export the certificates as their own separate files. This will mean all we have to do is copy 2 of those and ZNC will work nicely.\ntraefik-certs-dumper:  image: ldez/traefik-certs-dumper:v2.7.0  entrypoint: sh -c \u0026#39;traefik-certs-dumper file --version v2 --domain-subdir --crt-ext=.pem --key-ext=.pem --watch --source /data/acme.json --dest /data/certs/\u0026#39;  labels:  - \u0026#34;traefik.enable=false\u0026#34;  volumes:  - \u0026#34;certs:/data\u0026#34; As per usual, specify a version. If this gets a breaking change, it has the potential to affect Traefik, which will affect every container that you\u0026rsquo;re reverse proxying, so be careful when upgrading. Read the changelog. One key here is that the volume that TCD uses must be the same as Traefik. This is because they need to access the same data (that acme.json file), so there\u0026rsquo;s no point creating a new volume and copying it across.\nI\u0026rsquo;ve tweaked the entrypoint command here from a few tries at this with the various options from the README file in the repo.\n--version v2 tells TCD that we\u0026rsquo;re using Traefik v2.\n--domain-subdir tells TCD to put the certs in differnt directories based on the host subdomain. This will make the right files easy to find and also easier to script when I eventually get around to doing that.\n--cert-ext=.pem and --key-ext=.pem just gets us the files in the format that we want, saves conversion after the fact.\n--watch tells TCD to watch the JSON file for new certs and for cert updates which saves us the trouble of restarting the container ever.\nObviously --source and --dest tell TCD where to look for the JSON file and where to dump the cert files. The repo README seemed to prefer the /data location so that\u0026rsquo;s just where I mapped my volume and therefore, where the certs will go. You could always map a separate volume for the --dest if you liked.\n3.1 Give ZNC The Certs Now, once you add this to your docker-compose.yml and bring it up, you\u0026rsquo;ll notice a bunch of subdirectories in your --dest directory. The below is truncated for brevity.\n. ├── [-rw------- 117K] acme.json └── [drwxr-xr-x 4.0K] certs  ├── [drwxr-xr-x 4.0K] sub.domain.1  │ ├── [-rw-r--r-- 3.8K] certificate.pem  │ └── [-rw------- 3.2K] privatekey.pem  ├── [drwxr-xr-x 4.0K] sub.domain.2  │ ├── [-rw-r--r-- 3.8K] certificate.pem  │ └── [-rw------- 3.2K] privatekey.pem  ├── [drwxr-xr-x 4.0K] sub.domain.2  │ ├── [-rw-r--r-- 3.8K] certificate.pem  │ └── [-rw------- 3.2K] privatekey.pem  ├── [drwxr-xr-x 4.0K] private  │ └── [-rw------- 3.2K] letsencrypt.pem All you have to do is copy the relevant .pem files over to the root of the ZNC volume. Make sure that the filename of the certs matches the entry in your znc.conf and you should be good to go. At some point in the future I\u0026rsquo;ll be taking advantage of the --post-hook option in order to have this magically copy whenever our cert is renewed but that\u0026rsquo;s an issue for another post.\nSmall warning here, leave the private folder alone, it\u0026rsquo;s what Traefik uses to authenticate you to LetsEncrypt. You don\u0026rsquo;t really have a need to use that so ignore it, \u0026lsquo;kay?\n4 - This Ain\u0026rsquo;t Your Grandaddy\u0026rsquo;s Chat System Now we need to bring it all together. As per the normal process, run docker-compose up -d for the magic to get underway.\nIf you\u0026rsquo;re monitoring the Traefik logs, you\u0026rsquo;ll see it pick up the new container event and obtain the SSL certificates. If you\u0026rsquo;re not, give it 10 seconds or so and then open a web browser to the domain you\u0026rsquo;ve used.\nNow sign in, add a network and get to connecting! Any further details can be found on the ZNC wiki which is pretty comprehensive.\nMy full ZNC docker-compose.yml file:\nversion: \u0026#39;3\u0026#39;  services:  znc:  container_name: znc  image: znc:1.8.0  restart: unless-stopped  ports:  - 6697:6697  labels:  - \u0026#34;traefik.enable=true\u0026#34;  # Web Frontend Rules  - \u0026#34;traefik.http.routers.znc.entrypoints=https\u0026#34;  - \u0026#34;traefik.http.routers.znc.rule=Host(`sub.domain.tld`)\u0026#34;  - \u0026#34;traefik.http.routers.znc.tls.certresolver=le\u0026#34;  - \u0026#34;traefik.http.services.znc.loadbalancer.server.port=8080\u0026#34;  volumes:  - znc_data:/znc-data  networks:  - traefik_proxy  volumes:  znc_data:  networks:  traefik_proxy:  external: true My full Traefik + TCD docker-compose.yml file:\nversion: \u0026#34;3.3\u0026#34;  services:  traefik:  container_name: traefik  image: traefik:v2.2.0  command:  #- --log.level=DEBUG  # Entrypoints  - --entrypoints.http.address=:80  - --entrypoints.https.address=:443  # Provider Info  - --providers.docker  # Certificate Resolver Info  - --certificatesresolvers.le.acme.email=your@domain.tld  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json  - --certificatesresolvers.le.acme.tlschallenge=true  labels:  # Middleware Redirect  - \u0026#34;traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\u0026#34;  # Global HTTP -\u0026gt; HTTPS Redirect  - \u0026#34;traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\u0026#34;  - \u0026#34;traefik.http.routers.redirs.entrypoints=http\u0026#34;  - \u0026#34;traefik.http.routers.redirs.middlewares=https-redirect\u0026#34;  ports:  - \u0026#34;80:80\u0026#34;  - \u0026#34;443:443\u0026#34;  volumes:  - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34;  - \u0026#34;certs:/letsencrypt\u0026#34;  restart: unless-stopped  networks:  - proxy   traefik-certs-dumper:  image: ldez/traefik-certs-dumper:v2.7.0  entrypoint: sh -c \u0026#39;traefik-certs-dumper file --version v2 --domain-subdir --crt-ext=.pem --key-ext=.pem --watch --source /data/acme.json --dest /data/certs/\u0026#39;  labels:  - \u0026#34;traefik.enable=false\u0026#34;  volumes:  - \u0026#34;certs:/data\u0026#34;  volumes:  certs:  networks:  proxy:  driver: bridge ","permalink":"https://dangerous.tech/posts/20200608/znc+docker_acontainerizedircbouncer/","summary":"Twitter? Garbage. Facebook? Garbage. Do you enjoy having your data harvested and sold? No? Good. Back in the day, there was this thing called Internet Relay Chat. What if I told you\u0026hellip; It still exists! Internet socializing without all the Silicon Valley data theft! But due to how the ecosystem works, any time you\u0026rsquo;re not actively connected to the server, you don\u0026rsquo;t receive any messages. This means that you don\u0026rsquo;t get to see conversations that happen while you\u0026rsquo;re offline, even if somebody mentions you!","title":"ZNC + Docker - A Containerized IRC Bouncer"},{"content":"For many years, I used NGINX as a reverse proxy. It\u0026rsquo;s pretty bulletproof as long as you have your configuration set up properly from the get-go. There\u0026rsquo;s even a number of ways to automatially create new SSL certs for new containers but this mostly has to be done in a separate container itself. This makes the process of upgrading, testing, rolling back, patching and whatnot a bit of a mither. Enter Traefik.\nIf you saw the comparison post on why I chose Traefik vs Caddy then you\u0026rsquo;ll know I liked both of them, but I\u0026rsquo;m glad that I made the choice that I did. Since that post, Traefik has gone fully 2.0, updated a lot of their documentaion and just keeps getting better and better. I will still keep a cursory eye on Caddy but I doubt I\u0026rsquo;ll be switching over any time soon.\nTraefik support the defining of configuration via command line arguments or via a TOML file. To keep things simple and not require the backing up of an extra file, I run my container with command line arguments. This means all of the config is stored within the docker-compose file and makes it rather easy to share. The full config will be at the end of the post, but for now, let\u0026rsquo;s go through it in smaller chunks.\nTraefik Container Walkthrough version: \u0026#34;3.3\u0026#34;  services:  traefik:  container_name: traefik  image: traefik:v2.2.0  command: Obviously this is just the headings and whatnot, what you name the service/container is up to you. The key bit is that you should peg your container to an actual version, not just latest, to save upgrading your container in the future and encountering breaking changes which destroys your reverse proxy. You will get log messages from time to time about upgrades if they are available. The command section is where we pass the command line arguments to the Traefik binary that will run in the container.\n#- --log.level=DEBUG Useful if you need to debug/troubleshoot your config (obviously) but it does produce a LOT of noise so disable once you\u0026rsquo;re up and running.\n# Entrypoints  - --entrypoints.http.address=:80  - --entrypoints.https.address=:443 Entrypoints are essentially where you\u0026rsquo;re expecting traffic to come in to Traefik. Here, we set the address of an entrypoint called http and https to their relevant ports. You could very well define - --entrypoints.irc.address=:6697 if you liked.\n# Provider Info  - --providers.docker Again, self-explannatory really. This tells Traefik that we\u0026rsquo;re dealing with docker containers. There are plenty of other supported providers out there too.\n# Certificate Resolver Info  - --certificatesresolvers.le.acme.email=your@email.domain  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json  - --certificatesresolvers.le.acme.tlschallenge=true This is probably my favourite part, the auto SSL cert retrieval. The le portion is configurable and this is what you\u0026rsquo;ll reference in your container setups, along with a Host(`sub.domain.tld`) rule. See the bottom of this post for an example using my Jenkins container.\nThat\u0026rsquo;s it for the basics, really. But, because I\u0026rsquo;m usually not content with the basics, here\u0026rsquo;s some more advanced config.\nlabels:  # Middleware Redirect  - \u0026#34;traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\u0026#34;  # Global HTTP -\u0026gt; HTTPS Redirect  - \u0026#34;traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\u0026#34;  - \u0026#34;traefik.http.routers.redirs.entrypoints=http\u0026#34;  - \u0026#34;traefik.http.routers.redirs.middlewares=https-redirect\u0026#34; This section creates a middleware element and a router to redirect all HTTP traffic to HTTPS. Setting this as a label on the Traefik container itself means that you don\u0026rsquo;t have to create individual middleware for each new container and then add the redir config into those containers routers in order for this to function. Much simpler and I haven\u0026rsquo;t found a problem with it thus far (I\u0026rsquo;m running 8-10 containers at any one time).\nports:  - \u0026#34;80:80\u0026#34;  - \u0026#34;443:443\u0026#34;  volumes:  - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34;  - \u0026#34;certs:/letsencrypt\u0026#34;  restart: unless-stopped  networks:  - proxy  volumes:  certs:  networks:  proxy:  driver: bridge The end part is all fairly self-explannatory too, if you\u0026rsquo;ve worked with containers before. We set up a volume to hold our certs JSON file, and we create the proxy network, which on my host is the only network which communicates with the outside world. We need to bind port 80 and 443 to this container because they will always be handling the public traffic routing, that\u0026rsquo; kind of what a reverse proxy is for\u0026hellip;\nBy virtue of the --provider=docker flag we went through earlier, Traefik knows that it should be looking for containers on this network so that\u0026rsquo;s what it will check when it receives new events from the /var/run/docker.sock which we\u0026rsquo;ve allowed it to see. That means that you don\u0026rsquo;t have to expose port 80 of 443 in the individual containers\u0026rsquo; docker-compose.yml files, you just have to add a few labels to point Traefik in the right direction (and yes, it supports external -\u0026gt; internal port redirection too so those containers with fixed internal ports can be mapped just fine).\nClient Container Walkthrough We\u0026rsquo;ll leave out the boring headers this time, the same advice applies from the Traefik header portion.\nlabels:  - \u0026#34;traefik.enable=true\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.entrypoints=https\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.rule=Host(`sub.domain.tld`)\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.tls.certresolver=le\u0026#34;  - \u0026#34;traefik.http.services.jenkins.loadbalancer.server.port=8080\u0026#34; The labels section is the key bit of client config we need for Traefik. This tells Traefik to enable this container for reverse proxy goodness, to use our entrypoint (https) and out certresolver (le) which we defined earlier, as well as uses the Host(`sub.domain.tld`) rule.\nThe new thing here is the loadbalancer rule, which is how you can enable the external -\u0026gt; internal port mapping that I mentioned earlier. This will cause cause Traefik to route incoming traffic on the entrypoint (https/:443 here) to the specified internal port (8080 here) of the container.\nnetworks:  - traefik_proxy  networks:  traefik_proxy:  external: true Here we make sure that the container has the traefik_proxy network attached as an external network. This was defined in the Traefik container simply as proxy but Docker references these things like so: service_thing so if you run docker network list then you\u0026rsquo;ll see the correct network to add. You can also run docker network inspect your_proxy_network and look at the \u0026quot;Containers\u0026quot; key to see that the traefik container is in there.\nFull Traefik Container YAML version: \u0026#34;3.3\u0026#34;  services:  traefik:  container_name: traefik  image: traefik:v2.2.0  command:  #- --log.level=DEBUG  # Entrypoints  - --entrypoints.http.address=:80  - --entrypoints.https.address=:443  # Provider Info  - --providers.docker  # Certificate Resolver Info  - --certificatesresolvers.le.acme.email=your@email.domain  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json  - --certificatesresolvers.le.acme.tlschallenge=true  labels:  # Middleware Redirect  - \u0026#34;traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\u0026#34;  # Global HTTP -\u0026gt; HTTPS Redirect  - \u0026#34;traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\u0026#34;  - \u0026#34;traefik.http.routers.redirs.entrypoints=http\u0026#34;  - \u0026#34;traefik.http.routers.redirs.middlewares=https-redirect\u0026#34;  ports:  - \u0026#34;80:80\u0026#34;  - \u0026#34;443:443\u0026#34;  volumes:  - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34;  - \u0026#34;certs:/letsencrypt\u0026#34;  restart: unless-stopped  networks:  - proxy  volumes:  certs:  networks:  proxy:  driver: bridge Full Client (Jenkins) Container Walkthrough version: \u0026#39;3\u0026#39;  services:  jenkins:  container_name: jenkins  image: jenkins/jenkins:lts  restart: unless-stopped  labels:  - \u0026#34;traefik.enable=true\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.entrypoints=https\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.rule=Host(`sub.domain.tld`)\u0026#34;  - \u0026#34;traefik.http.routers.jenkins.tls.certresolver=le\u0026#34;  - \u0026#34;traefik.http.services.jenkins.loadbalancer.server.port=8080\u0026#34;  volumes:  - jenkins_home:/var/jenkins_home  networks:  - traefik_proxy  volumes:  jenkins_home:  networks:  traefik_proxy:  external: true ","permalink":"https://dangerous.tech/posts/20200601/setuptraefikondockeramodernreverseproxysolution/","summary":"For many years, I used NGINX as a reverse proxy. It\u0026rsquo;s pretty bulletproof as long as you have your configuration set up properly from the get-go. There\u0026rsquo;s even a number of ways to automatially create new SSL certs for new containers but this mostly has to be done in a separate container itself. This makes the process of upgrading, testing, rolling back, patching and whatnot a bit of a mither. Enter Traefik.","title":"Set Up Traefik on Docker - A Modern Reverse Proxy Solution"},{"content":"When first moving to i3 as a window manager, you may have relished the opportunity to learn a tonne of new shortcut keys on your journey to being the neckbeardiest of them all (I know I certainly did). At some point along the way, you probably realised that it would be useful to start certain programs/scripts when you first login. As this is linux, there\u0026rsquo;s about 15 different ways to do this, but I\u0026rsquo;m going to show you my favourite. It\u0026rsquo;s my favourite for a few reasons:\n You can keep all of your startup scripts in one place (likely ~/.config/i3/scripts if you\u0026rsquo;re following my example) If you ever close one of these and want to start them again, just hit your i3 config reload key (mod + shift + r if you\u0026rsquo;re using my dotfiles) If you ever need to modify the way that the program is launched, you just have to tweak the script, no extra lines in your i3 config file  Ingredients  Your i3 config file (hopefully ~/.config/i3/config) The ability to write a shell script (may I recommend Neovim for even more neckbeard clout)  Method 1 - Create a Shell Script So the way we\u0026rsquo;re going to do this is to run a shell script from within our i3 config, then the shell script is going to run the program. You could just add the program itself as a line in your i3 config file but there\u0026rsquo;s 2 major benefits to doing it this way:\n PID detection - we don\u0026rsquo;t want to run a new copy of the program every time we reload our i3 config, that will get messy fast Less clutter in the i3 config - the i3 config file is already a bit of chunky one, let\u0026rsquo;s not add to that, eh?  Using your editor of choice create a new Shell script (I\u0026rsquo;m using this to launch Nextcloud, hence the below):\nif [[ ! $(pgrep -u $UID -x nextcloud) ]]; then  nextcloud \u0026amp; fi All this is doing is using pgrep to check for a PID already launched by your User ID, to avoid double/triple/etc launching the same thing. If that\u0026rsquo;s not found, it will launch a new instance of that (and background it with \u0026amp; otherwise the script will hold up the loading of i3, which nobody wants). It\u0026rsquo;s worth mentioning that if the process has a different name than you\u0026rsquo;re expecting then this will fail. Best to run pgrep -u $UID -x PROCESS_NAME when it\u0026rsquo;s active just to be sure\n2 - Add a Reference to the i3 Config File Add the below to your i3 config file, assuming your script is in the same location as mentioned above (mine is below my Polybar config but you can just stick it at the end):\nexec_always --no-startup-id $HOME/.config/i3/scripts/YOUR_SCRIPT.sh Now reload i3 and viola, your program has launched. Now reload it again, maybe even a few times. You should notice that if it\u0026rsquo;s already launched, the i3 reload won\u0026rsquo;t relauch it, but if you close it the reload will launch it. Magic!\n","permalink":"https://dangerous.tech/posts/20200525/runatloginwithi3/","summary":"When first moving to i3 as a window manager, you may have relished the opportunity to learn a tonne of new shortcut keys on your journey to being the neckbeardiest of them all (I know I certainly did). At some point along the way, you probably realised that it would be useful to start certain programs/scripts when you first login. As this is linux, there\u0026rsquo;s about 15 different ways to do this, but I\u0026rsquo;m going to show you my favourite.","title":"Running a Script at Login with i3"},{"content":"Managing .gitignore For Fun And Profit You know when you see that little green \u0026lsquo;Verified\u0026rsquo; badge next to your commits on GitHub? The one that makes it feel all official? Notice how when you commit and push from the commandline you don\u0026rsquo;t get that? If you\u0026rsquo;ve ever wondered why, this post is for you! Also if you realise that signing your commits is a good idea generally because somethine something security\u0026hellip; It works for you too.\nPrerequisites  gpg installed on the system you\u0026rsquo;re setting up commit signing from (gpg --version or gpg2 --version to verify) The ability to reach GitHub. This can be from the same machine, or you can be SSHed in, you\u0026rsquo;ll need to copy an exported key from the commandline to a browser window and you don\u0026rsquo;t want to type it all out\u0026hellip;  1 - Generate the Key Run gpg --full-generate-key to kick off the process. Make sure that you make your key 4096 bits, GitHub won\u0026rsquo;t accept anything less. (I believe that all gpg commands can be substituted for gpg2 from this point onwards but I haven\u0026rsquo;t fully tested that so YMMV)\n2 - Export the Key Now we need to export the key in a format that we can give to GitHub.\ngpg --list-secret-keys --keyid-format LONG will give you a list of your secret keys, copy the ID in the same place as the red box in the screenshot and run the gpg --armor --export YOURIDHERE to get the GitHubbable part. Copy this key, all the way from -----BEGIN PGP PUBLIC KEY BLOCK----- to -----END PGP PUBLIC KEY BLOCK-----\n3 - Upload Key to GitHub This is assuming that you\u0026rsquo;re using GitHub here, you would have to upload this in basically the same format to BitBucket or wherever else.\nHead to https://github.com/settings/keys and locate the GPG keys section. Click New GPG key.\nPaste in the exported key from the previous command into the box and click Add GPG key once again.\nVerify that the key is now showing in the GPG keys list and has the correct email address associated with it.\n4 - Complete Git Config Check that you don\u0026rsquo;t already have a .gitconfig file using cat. If you do, you can probably skip some of these config steps. The last 2 are the key ones here. Use the same Key ID and for the signing key that you used in the export command from step 2.\ngit config --global user.name \u0026#34;your name\u0026#34; git config --global user.email your@email.address git config --global user.signingkey YOURIDHERE git config --global commit.gpgsign true 5 - Do All The git Things Commit, Commit, Commit! You can verify the commit using git verify-commit commitid\n","permalink":"https://dangerous.tech/posts/20200514/signingyourgitcommitsbydefault/","summary":"Managing .gitignore For Fun And Profit You know when you see that little green \u0026lsquo;Verified\u0026rsquo; badge next to your commits on GitHub? The one that makes it feel all official? Notice how when you commit and push from the commandline you don\u0026rsquo;t get that? If you\u0026rsquo;ve ever wondered why, this post is for you! Also if you realise that signing your commits is a good idea generally because somethine something security\u0026hellip; It works for you too.","title":"Signing Your Git Commits by Default"},{"content":"Pan-dev-mic? So, assuming that you\u0026rsquo;re living in the world right now you\u0026rsquo;re probably either working from home, furloughed or have been laid off. My condolences to those not in the first category, although financial troubles aside, enjoy your increased free time. I\u0026rsquo;m in the 100% working from home category, which means I have all of my Raspberry Pis, microcontrollers, PC builds and such laying around me but I have my work laptop hooked up to the main I/O in this room. Short of buying a high quality KVM that supports all the I/O that I would want to be able to switch between them quickly (shoutout Level1Techs store if you\u0026rsquo;re in the market), I don\u0026rsquo;t really want to have 3 laptops open at once to be able to access all the different dev environments I need for testing (I\u0026rsquo;ve definitely done that in the past though\u0026hellip;).\nThe Solution Enter VS Code. I\u0026rsquo;ve used VS Code as my main IDE for basically everything for over a year now. It\u0026rsquo;s a brilliant environment for editing any kind of code, there\u0026rsquo;s always tonnes of plugins and the application itself is stable yet has frequent updates. They also seem to listen to what the dev community really wants as added features and (I hope you\u0026rsquo;re sitting down) actually add them!\nI\u0026rsquo;d heard about the Remote Dev features on a few podcasts a while back but I\u0026rsquo;d never really had the need to try them out. I\u0026rsquo;m always working on Linux machines so it\u0026rsquo;s pretty easy to spin up a venv or a container and test my code. But these days, on the work laptop, I\u0026rsquo;m chained to Windows! No WSL either, the higher ups think that\u0026rsquo;s the devil or something so we\u0026rsquo;re stuck with Billy Basic Winblows 10. The saving grace? OpenSSH being included with Win10 since 1709 or something like that. This means that anything we can SSH to, we can develop on!\nPrerequisites  Obviously make sure you\u0026rsquo;ve got VS Code installed. It\u0026rsquo;s code now on the Arch repos, vscode in Chocolatey and it\u0026rsquo;s also available as a --classic snap (as code) wherever snaps are sold. Make sure you can SSH to whatever device you\u0026rsquo;re trying to develop on. Most corporate VPNs have breakouts for 192.168.0.0/16 at least, with some opting for 172 or 10 range split tunnels depending on what the corporate ifrastructure is running wherever you are, so you may very well be able to get to your device with no troubles. The credentials for a user on the dev device (obviously?).  1 - Find the Extension(s) VS Code has 3 remote dev extensions:\n SSH Containers WSL  Obviously you can just choose whichever one you like from those 3, or they have the extension, pictured above, which is basically a meta package and will install all 3. I did notice that when I went to install the meta packadge, SSH and Containers installed fine but WSL hung for quite some time and I wound up having to reload the window. I\u0026rsquo;d say if you don\u0026rsquo;t have WSL activated, don\u0026rsquo;t bother trying to install that one. Install whichever are relevant, we\u0026rsquo;ll be going through SSH configurations specifically in this post.\n2 - Add A New SSH Connection Pt 1 Open the command palette (F1 or Ctrl + Shift + P) and search for remote-ssh. You\u0026rsquo;ll want to select Add New SSH Host....\n3 - Add A New SSH Connection Pt 2 Now, as the example says, go ahead and input the command required to connect to the server. Just ssh user@domain should be enough here. I haven\u0026rsquo;t tried it but I assume that you could use Mosh here if you didn\u0026rsquo;t have a particularly stable connection to the remote host.\n4 - Add A New SSH Connection Pt 3 Now you\u0026rsquo;ll want to select which SSH Config file to update. Either is probably fine, I tend to go with the former because it\u0026rsquo;s user specific. You\u0026rsquo;ll definitely want the first option if you\u0026rsquo;re on a multi-user machine.\n5 - Add A New SSH Connection Pt 4 You\u0026rsquo;ll now notice this little toasty boi in the bottom right of your screen. If you want to use SSH keys to access your remote machine, click \u0026lsquo;Open Config\u0026rsquo; and continue with the optional steps. If not, skip em and head to step 9, just enter the password each time you connect.\n6 - Open The SSH Config File (OPTIONAL) Looks like any old SSH Config file, nothing to see here.\n7 - Get You An SSH Key, Son (OPTIONAL) With the magic of OpenSSH, you should have the ssh-keygen command available to you. Use powershell (or cmd if you\u0026rsquo;re a peasant\u0026hellip;) to generate an SSH key using ssh-keygen -t rsa -C key_comment. Follow the prompts, set a passphrase if you like (I left mine because this is only a Raspberry Pi and I don\u0026rsquo;t really care if I lose this key to it) and specificy a save location and you\u0026rsquo;re good to go.\n8 - Add Your SSH Key To The SSH Config File (OPTIONAL) Hope you remembererd where you put that SSH key, you\u0026rsquo;re going to need that path right about now. Add a line to the SSH Config file as in the screenshot, just needs to be IdentityFile path/to/key/file. You\u0026rsquo;ll notice I also changed the Host portion of mine, you can change this to whatever you like, just keep the HostName address the same.\n9 - Begin The Remote Connection Finally, right? All this prep and now you can finally initiate the connection! Head to the Remote Explorer and you should see the connection you\u0026rsquo;ve just added (displayed based on that Host line in the config).\n10 - Confirm The Remote OS Apparently sometimes VS Code will autodetect this, but I had to confirm it every time I\u0026rsquo;ve used this feature so far so who knows\u0026hellip; Just select the right platform, hit enter and you\u0026rsquo;ll be on your way.\n11 - Confirm The Remote Fingerprint Unless you\u0026rsquo;ve already SSH\u0026rsquo;ed to this host and have it\u0026rsquo;s details in your known_hosts file, you\u0026rsquo;ll need to confirm it now.\n12 - Enter Your Password Now is the time. SSH key users, this is the last time you\u0026rsquo;ll have to enter a password to connect (unless you added one to your SSH key but I can\u0026rsquo;t stop you there, I\u0026rsquo;m not your dad).\n13 - The Install Begins It turns out that VS Code dumps a bunch of nonsense on the remote machine in order to make the remote dev environment work. If you open the terminal now, you\u0026rsquo;ll be able to see if doing it\u0026rsquo;s work.\n14 - Open The Home Folder (OPTIONAL) Another one for you SSH key users. I\u0026rsquo;m assuming here that you haven\u0026rsquo;t already added this key to the authorized_keys file on the remote machine. If you have skip to step 19. If not, click \u0026lsquo;Open Folder\u0026rsquo; and open the user\u0026rsquo;s Home dir (or their .ssh dir if they already have one).\n15 - Create The .ssh Directory (OPTIONAL) This one\u0026rsquo;s not rocket science, create a new folder called .ssh within the Home dir if it doesn\u0026rsquo;t already exist.\n16 - Create The authorized_keys File (OPTIONAL) Now create a file called authorized_keys (again, if it doesn\u0026rsquo;t already exist - if it does, just edit it).\n17 - Copy Ze Public Key (OPTIONAL) Echo out the public part of the key that you created earlier (type filename on windows, cat filename on *nix).\n18 - Paste Ze Public Key (OPTIONAL) Paste that key into the authorized_keys file. Just the bit beginning with ssh-rsa and ending with whatever your comment was from when you created the key.\n19 - Close The Remote Connection (OPTIONAL) Now, close the remote connection. We\u0026rsquo;ll reopen it using our key to authenticate, and you don\u0026rsquo;t get the instanst gratification of seeing that in action unless you close the window. Ashes to ashes, dust to dust, tis the circle of life, my friends.\n20 - Remove The Folder From VS Code (OPTIONAL) VS Code remembers the home folder you were just in but unless you run your code straight out of there (which you don\u0026rsquo;t\u0026hellip;\u0026hellip; do you\u0026hellip;.?) then you don\u0026rsquo;t need this in the history.\n21 - To Open Or To Clone? (OPTIONAL) Now, relaunch the connection the same way you did in step 9, except this time you won\u0026rsquo;t have to do any of the additional nonsense. You should connect straight in and be greeted with the File Browser. Either open a folder which already has a coding project in or clone one, the decision\u0026rsquo;s all yours.\n22 - A Point About Extensions You\u0026rsquo;ll now notice if you open the extensions sidebar you have a section for local extensions and one for your remote machine. Any extensions that you need for debugging, building, executing, etc need to be installed on the remote machine. Anything that just syntax highlighting, linting, etc will work just fine on the local machine. Every time you install en extension while you\u0026rsquo;re connected to a remote host, it will install it both on the local machine and the remote by default. If you select the extension to bring up the page properly, you get the option to just install on the remote, should you wish.\nI always like to have GitLens on the remote machine because then it can keep the state of the repo on the remote machine in check. See the post about setting up your .gitconfig(I\u0026rsquo;ll link this when it\u0026rsquo;s live) for more information on Git config in general.\n23 - Final Interface Walkthrough I\u0026rsquo;ll leave you with a few pointers on the final interface. Hack the planet!\n","permalink":"https://dangerous.tech/posts/20200508/remotedeveopmentwithvscode/","summary":"Pan-dev-mic? So, assuming that you\u0026rsquo;re living in the world right now you\u0026rsquo;re probably either working from home, furloughed or have been laid off. My condolences to those not in the first category, although financial troubles aside, enjoy your increased free time. I\u0026rsquo;m in the 100% working from home category, which means I have all of my Raspberry Pis, microcontrollers, PC builds and such laying around me but I have my work laptop hooked up to the main I/O in this room.","title":"Remote Development with VS Code"},{"content":"The Problem Let\u0026rsquo;s say you have a container, say for example that it\u0026rsquo;s a container you rely on to store and sync a lot of your data. Say that one day, you notice that all of your devices stop syncing and throw time out errors. Say that you\u0026rsquo;re quite frustrated with this because to a certain extent, this container stack was supposed to be set and forget. Say that you go to the web GUI and you see this:\nWhy could this be? You haven\u0026rsquo;t changed anything in this stack for a few weeks and it\u0026rsquo;s been running smoothly up until now\u0026hellip;\nLet\u0026rsquo;s take a look at the logs (docker-compose logs -f):\n(if you don\u0026rsquo;t have debug turned on, you\u0026rsquo;ll need it for this step - enable it and restart the container, then reload the web GUI)\nThe key parts to look for here are the Host field, which should contain the URL of the container that\u0026rsquo;s causing problems, and the ForwardURL field, which is where Traefik is trying to route your\u0026hellip; traffic. I\u0026rsquo;ve whited out certain sections to protect the innocent but you can still see the key bits. Most interestingly is that when I was bringing up this container stack a few weeks ago, I noted it\u0026rsquo;s 192.168 address range. You\u0026rsquo;ll see from the screenshot that the address Traefik is trying to send to is a 172.27 address\u0026hellip;\u0026hellip;. If you\u0026rsquo;ve ever spent any time with IP addresses, you\u0026rsquo;ll know that this is rather incorrect, and not just incorrect due to some sort of chance act or stale cache. Let\u0026rsquo;s investigate further - docker container inspect the-problem-container:\nYou\u0026rsquo;ll see the problem quite clearly here in the IPAddress field - Traefik is trying to route to the _backend network, which only the internals of the container stack have access to because\u0026hellip; security. Because of that, Traefik is receiving timeouts as the interface that it has on the traefik_proxy network isn\u0026rsquo;t allowed in to the _backend network.\nThe Solution Now that we\u0026rsquo;ve identified the problem, how do we fix it? We tell Traefik exactly which network it should be detecting the container on, of course! How do we do this? With a label, just like all of our other Traefik config.\n- \u0026quot;traefik.docker.network=traefik_proxy\u0026quot;\nSimply add this label to the problem container, recreate both containers for safety (start with the problem one, do Traefik last - and if you\u0026rsquo;ve still got debug turned on you can turn it off, it\u0026rsquo;s quite noisy otherwise) and you should be good to go. Check the web GUI and verify that you\u0026rsquo;re all back up to speed. Now go and add this label to every other container you\u0026rsquo;re using Traefik to route to just in case and you\u0026rsquo;ll set your mind at ease.\nAddendum You don\u0026rsquo;t necessarily have to add it to all of your containers, I\u0026rsquo;ve only ever seen issues with containers that have multiple networks attached. So just go and add it to the relevant ones.\nSOTP: Who Got It? - ATTYA Super chill electronic music, great to work to.\n","permalink":"https://dangerous.tech/posts/20200505/dockerrouting_incorrectipaddressdetectedbytraefik/","summary":"The Problem Let\u0026rsquo;s say you have a container, say for example that it\u0026rsquo;s a container you rely on to store and sync a lot of your data. Say that one day, you notice that all of your devices stop syncing and throw time out errors. Say that you\u0026rsquo;re quite frustrated with this because to a certain extent, this container stack was supposed to be set and forget. Say that you go to the web GUI and you see this:","title":"Docker Routing - Incorrect IP Address Detected by Traefik"}]